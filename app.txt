# app.py
# Horse Race Ready â€” IQ Mode ðŸ”¥ (Beginner-friendly + Pro controls)
# Streamlit single-file app with: bias/run-style/J/T angles â€¢ MSW/FTS logic â€¢
# live tote (quick paste or table) â€¢ overlays/EV â€¢ ticket builders (Win/Ex/Tri/Super/SH5) â€¢
# confidence bands â€¢ session ROI tracker â€¢ glossary â€¢ Beginner Mode (guided).

import os, re, json, math
from typing import List, Dict
import statistics as stats

import pandas as pd
import numpy as np
import streamlit as st

# ===================== Page / Model Settings =====================
st.set_page_config(page_title="Horse Race Ready â€” IQ Mode", page_icon="ðŸ‡", layout="wide")
st.title("ðŸ‡ Horse Race Ready â€” IQ Mode")

# Glossary popover (simple & friendly)
with st.popover("Glossary"):
    st.markdown("""
**Running styles**: E (early), E/P (early/presser), P (mid-pack), S (closer).  
**Bias**: Track/post pattern favoring Inside (1â€“3), Mid (4â€“7), Outside (8+).  
**Overlay**: Board price > our fair price â†’ positive value.  
**Underlay**: Board too short vs. fair â†’ avoid/underneath only.  
**EV per $1**: Expected return per dollar at current odds (positive is good).
""")

# Model settings (safe defaults)
MODEL = st.secrets.get("OPENAI_MODEL", "gpt-5")
TEMP  = float(st.secrets.get("OPENAI_TEMPERATURE", "0.5"))

OPENAI_API_KEY = st.secrets.get("OPENAI_API_KEY") or os.getenv("OPENAI_API_KEY")
if not OPENAI_API_KEY:
    st.error("Add your key to `.streamlit/secrets.toml`:\n\nOPENAI_API_KEY = \"sk-...\"")
    st.stop()

# Prefer new SDK; fall back to legacy
use_sdk_v1 = True
try:
    from openai import OpenAI
    client = OpenAI(api_key=OPENAI_API_KEY)
except Exception:
    import openai
    openai.api_key = OPENAI_API_KEY
    use_sdk_v1 = False

# ---------- Legal/Links (override via secrets) ----------
REPO_USER = st.secrets.get("GH_USER", "craigstephens859-prog")
REPO_NAME = st.secrets.get("GH_REPO", "horse-race-ready")
_BASE_GH = f"https://github.com/{REPO_USER}/{REPO_NAME}/blob/main"
TERMS_URL   = st.secrets.get("TERMS_URL",   f"{_BASE_GH}/TERMS.md")
PRIVACY_URL = st.secrets.get("PRIVACY_URL", f"{_BASE_GH}/PRIVACY.md")
CONTACT_URL = st.secrets.get("CONTACT_URL", "mailto:bluegrassdude@icloud.com")
SUPPORT_EMAIL = st.secrets.get("SUPPORT_EMAIL", "bluegrassdude@icloud.com")

st.markdown(
    f"""
**Disclaimer:** Informational handicapping analysis only â€” **not** financial or wagering advice.  
Use at your own risk. By using this app, you agree to the
[Terms]({TERMS_URL}) and [Privacy Policy]({PRIVACY_URL}).  
Questions? <a href="mailto:bluegrassdude@icloud.com?subject=Horse%20Race%20Ready%20Support">bluegrassdude@icloud.com</a>.
""",
    unsafe_allow_html=True,
)

# ===================== Helpers =====================
def model_supports_temperature(model_name: str) -> bool:
    m = (model_name or "").lower()
    return not (m.startswith("gpt-5") or m.startswith("o4") or m.startswith("o3"))

def call_openai_messages(messages: List[Dict]) -> str:
    """Safe wrapper that omits temperature if the model rejects it."""
    if use_sdk_v1:
        try:
            kwargs = {"model": MODEL, "messages": messages}
            if model_supports_temperature(MODEL):
                kwargs["temperature"] = TEMP
            resp = client.chat.completions.create(**kwargs)
            return resp.choices[0].message.content
        except Exception as e:
            if "temperature" in str(e).lower() and "unsupported" in str(e).lower():
                resp = client.chat.completions.create(model=MODEL, messages=messages)
                return resp.choices[0].message.content
            raise
    else:
        try:
            kwargs = {"model": MODEL, "messages": messages}
            if model_supports_temperature(MODEL):
                kwargs["temperature"] = TEMP
            resp = openai.ChatCompletion.create(**kwargs)
            return resp["choices"][0]["message"]["content"]
        except Exception as e:
            if "temperature" in str(e).lower() and "unsupported" in str(e).lower():
                resp = openai.ChatCompletion.create(model=MODEL, messages=messages)
                return resp["choices"][0]["message"]["content"]
            raise

def detect_valid_race_headers(pp_text: str):
    toks = ("purse", "furlong", "mile", "clm", "allow", "stake", "pars", "post time")
    headers = []
    for m in re.finditer(r"(?mi)^\s*Race\s+(\d+)\b", pp_text or ""):
        start = m.start()
        win = (pp_text[m.end():m.end()+250] or "").lower()
        if any(t in win for t in toks):
            headers.append((start, int(m.group(1))))
    return headers

def extract_horses_and_styles(pp_text: str) -> pd.DataFrame:
    """
    Parse header lines like: '1 Holiday Fantasy (P 2)' / '3 McGeorge (E/P 4)'
    """
    pat = re.compile(
        r'^\s*(\d+)\s+([A-Za-z0-9\'\.\-\s&]+?)\s+\(\s*(E\/P|E|P|S)\s*[\d]*\s*\)',
        re.MULTILINE
    )
    rows = []
    for m in pat.finditer(pp_text or ""):
        rows.append({
            "#": m.group(1).strip(),
            "Horse": m.group(2).strip(),
            "DetectedStyle": m.group(3).replace("E/P", "E/P"),
            "OverrideStyle": "",
            "StyleStrength": "Solid",
        })
    # de-dupe
    seen = set(); uniq = []
    for r in rows:
        k = (r["#"], r["Horse"].lower())
        if k not in seen:
            seen.add(k); uniq.append(r)
    return pd.DataFrame(uniq)

def parse_stat_table_lines(lines: List[str]) -> pd.DataFrame:
    """
    Parse lines like: '1st time str   146   3%   25%   -1.22'
    """
    rows=[]
    for raw in lines:
        s = re.sub(r'\s+', ' ', raw.strip())
        if not s: continue
        m = re.match(r'(.+?)\s+(\d+)\s+(\d+)%\s+(\d+)%\s+([+-]?\d+(?:\.\d+)?)$', s)
        if m:
            rows.append({
                "Category": m.group(1),
                "Starts": int(m.group(2)),
                "Win%": float(m.group(3)),
                "ITM%": float(m.group(4)),
                "ROI": float(m.group(5)),
            })
    return pd.DataFrame(rows)

def _format_running_styles(df: pd.DataFrame) -> str:
    lines = []
    for _, r in df.iterrows():
        style = (r.get("OverrideStyle") or r.get("DetectedStyle") or "P").strip()
        strength = (r.get("StyleStrength") or "Solid").strip()
        lines.append(f"{r['Horse']} = {style} ({strength})")
    return "\n".join(lines) if lines else "None detected"

# ---------- Weights & Presets ----------
DEFAULT_WEIGHTS = {
    "global": {"pace_shape":1.0,"bias_fit":1.1,"class_form":1.0,"trs_jky":0.9,"pedigree":0.6,"workout_snap":0.7,"projection":1.0,"ft_firsters":1.0},
    ("Dirt","â‰¤6f"):  {"pace_shape":1.2,"bias_fit":1.2,"class_form":1.0,"trs_jky":0.9,"pedigree":0.5,"workout_snap":0.6,"projection":1.1,"ft_firsters":1.1},
    ("Dirt","6.5â€“7f"):{"pace_shape":1.1,"bias_fit":1.1,"class_form":1.0,"trs_jky":1.0,"pedigree":0.6,"workout_snap":0.7,"projection":1.1,"ft_firsters":1.1},
    ("Dirt","8f+"):  {"pace_shape":1.0,"bias_fit":1.1,"class_form":1.2,"trs_jky":1.0,"pedigree":0.7,"workout_snap":0.7,"projection":1.0,"ft_firsters":0.9},
    ("Turf","â‰¤6f"):  {"pace_shape":0.9,"bias_fit":1.0,"class_form":1.0,"trs_jky":1.0,"pedigree":0.9,"workout_snap":0.6,"projection":1.0,"ft_firsters":1.2},
    ("Turf","6.5â€“7f"):{"pace_shape":1.0,"bias_fit":1.0,"class_form":1.1,"trs_jky":1.0,"pedigree":0.9,"workout_snap":0.7,"projection":1.0,"ft_firsters":1.1},
    ("Turf","8f+"):  {"pace_shape":1.0,"bias_fit":1.1,"class_form":1.2,"trs_jky":1.1,"pedigree":1.0,"workout_snap":0.7,"projection":1.0,"ft_firsters":0.8},
    ("Synthetic","â‰¤6f"):{"pace_shape":1.0,"bias_fit":1.0,"class_form":1.0,"trs_jky":1.0,"pedigree":0.7,"workout_snap":0.6,"projection":1.0,"ft_firsters":1.1},
    ("Synthetic","6.5â€“7f"):{"pace_shape":1.0,"bias_fit":1.1,"class_form":1.0,"trs_jky":1.0,"pedigree":0.8,"workout_snap":0.6,"projection":1.0,"ft_firsters":1.0},
    ("Synthetic","8f+"):{"pace_shape":0.9,"bias_fit":1.0,"class_form":1.1,"trs_jky":1.0,"pedigree":0.9,"workout_snap":0.7,"projection":1.0,"ft_firsters":0.8},
}
def distance_bucket(distance_text: str) -> str:
    s=(distance_text or "").lower()
    if "6Â½" in s or "6 1/2" in s or "6.5" in s: return "6.5â€“7f"
    if "furlong" in s:
        m=re.search(r'(\d+(?:\.\d+)?)\s*furlong', s)
        if m:
            v=float(m.group(1))
            if v<=6.0: return "â‰¤6f"
            if v<=7.0: return "6.5â€“7f"
            return "8f+"
        return "â‰¤6f"
    if "mile" in s: return "8f+"
    return "â‰¤6f"
def get_weight_preset(surface: str, distance_txt: str) -> Dict[str,float]:
    return DEFAULT_WEIGHTS.get((surface, distance_bucket(distance_txt)), DEFAULT_WEIGHTS["global"])

# ---------- Bias logic ----------
def compute_post_bias_label(field_size: int) -> str:
    return f"Inside:1-3 | Mid:4-7 | Outside:{'8+' if field_size >= 8 else '8+'}"

# ---------- FTS / MSW logic (scoring helper for future use) ----------
def fts_score(snips: Dict[str, float]) -> float:
    td = min(max(snips.get("trainer_debut_win",0)/30.0,0),1)
    sd = min(max(snips.get("sire_first_out_win",0)/18.0,0),1)
    bw = min(snips.get("bullet_works",0)/2.0,1)
    rc = 1.0 if snips.get("recency_days",999) <= 15 else (0.6 if snips.get("recency_days",999) <= 28 else 0.3)
    ar = min(max(snips.get("auction_to_fee_ratio",0)/5.0,0),1)
    gw = 0.8 if snips.get("gate_works",0) else 0.4
    dm = 1.0 if snips.get("distance_match",0) else 0.6
    raw = 0.22*td + 0.22*sd + 0.16*bw + 0.12*rc + 0.14*ar + 0.07*gw + 0.07*dm
    return max(0.0, min(1.0, raw))

# ---------- Odds / overlay helpers ----------
def dec_to_prob(dec_odds: float) -> float:
    return 1.0/dec_odds if dec_odds and dec_odds > 0 else 0.0
def am_to_dec(american: float) -> float:
    return 1 + (american/100.0 if american > 0 else 100.0/abs(american))
def fair_to_american(p: float) -> float:
    if p <= 0: return float("inf")
    if p >= 1: return 0.0
    dec = 1.0/p
    return round((dec-1)*100,0) if dec >= 2 else round(-100/(dec-1),0)
def str_to_decimal_odds(s: str) -> float|None:
    s=s.strip()
    if not s: return None
    if re.fullmatch(r'[+-]?\d+(\.\d+)?', s):
        v=float(s); return max(v,1.01)
    if re.fullmatch(r'\+\d+', s) or re.fullmatch(r'-\d+', s):
        return am_to_dec(float(s))
    if "-" in s:
        a,b=s.split("-",1)
        try: return float(a)/float(b)+1.0
        except: return None
    if "/" in s:
        a,b=s.split("/",1)
        try: return float(a)/float(b)+1.0
        except: return None
    return None
def overlay_table(fair_probs: Dict[str,float], offered: Dict[str,float]) -> pd.DataFrame:
    rows=[]
    for h, p in fair_probs.items():
        fair_dec = 1.0/max(p, 1e-6)
        fair_am  = fair_to_american(p)
        off_dec  = offered.get(h)
        if off_dec is None: continue
        off_prob = dec_to_prob(off_dec)
        ev = (off_dec-1)*p - (1-p)
        rows.append({
            "Horse": h,
            "Fair %": round(p*100,2),
            "Fair (AM)": fair_am,
            "Board (dec)": round(off_dec,3),
            "Board %": round(off_prob*100,2),
            "Edge (Board%-Fair%)": round((off_prob-p)*100,2),
            "EV per $1": round(ev,3),
            "Overlay?": "YES" if off_prob < p else "No"
        })
    return pd.DataFrame(rows).sort_values(by=["Overlay?","EV per $1"], ascending=[False, False])

# ---------- Ticket cost helpers ----------
def superfecta_cost(a:int,b:int,c:int,d:int, base:float)->float: return base * a*b*c*d
def super_high5_cost(a:int,b:int,c:int,d:int,e:int, base:float)->float: return base * a*b*c*d*e

# ===================== Sidebar: Profiles & Controls =====================
with st.sidebar:
    st.header("Strategy Profile")
    profile = st.radio(
        "Profile (visible to everyone):",
        ["Value Hunter", "Balanced", "Exotic Builder", "Steady Chalk"],
        index=0,
        help="Toggles weighting & how aggressively we seek overlays."
    )
    iq_mode = st.toggle("IQ Mode (advanced heuristics, FTS logic, presets)", value=True)

    # Beginner Mode (guided)
    beginner_mode = st.toggle("Beginner Mode (guided)", value=True,
                              help="Hides advanced controls and shows a simple 3-step guide.")
    if beginner_mode:
        st.info("**Start here**\n\n1) Paste one raceâ€™s PP text.\n2) (Optional) add scratches or live odds.\n3) Click **Analyze this race**.")

    # Advanced controls (collapsed if Beginner Mode)
    if beginner_mode:
        with st.expander("Advanced controls (optional)", expanded=False):
            conf_band = st.slider("Confidence band Â± (points of win %)", 0.0, 10.0, 3.0, 0.5)
            press_threshold = st.slider("Press when overlay â‰¥ (percentage points)", 0.0, 15.0, 5.0, 0.5)
    else:
        conf_band = st.slider("Confidence band Â± (points of win %)", 0.0, 10.0, 3.0, 0.5)
        press_threshold = st.slider("Press when overlay â‰¥ (percentage points)", 0.0, 15.0, 5.0, 0.5)

# ===================== Main Flow =====================

# Step 1 â€” Paste PP
st.markdown("## Step 1 â€” Paste one race (PP text)")
st.caption("Tip: copy only one race from your PDF. If we detect more than one, weâ€™ll ask you to repaste.")
pp_text = st.text_area("BRIS PPs:", height=260, placeholder="Paste the full text block of a single raceâ€¦")

race_headers = detect_valid_race_headers(pp_text) if pp_text.strip() else []
if pp_text.strip():
    if len(race_headers) == 0:
        st.info("No explicit 'Race #' header detected â€” OK if itâ€™s a single race block.")
    elif len(race_headers) > 1:
        st.error(f"Detected **{len(race_headers)} races**. Paste **only one** race block.")
        st.stop()

# Surface / distance / notes
colA, colB, colC = st.columns([1.1,1,1])
with colA:
    surface_type = st.selectbox("Surface:", ["Dirt","Turf","Synthetic"], index=0)
with colB:
    default_dist = ""
    m = re.search(r'(\d+\s*Â½?|\d+\.\d+)\s*Furlongs|\b1\s*Mile', pp_text or "", flags=re.IGNORECASE)
    if m: default_dist = m.group(0)
    distance_txt = st.text_input("Distance label (for preset bucket):", value=default_dist or "6 Furlongs")
with colC:
    ml_context = st.text_input("Notes about the race (optional):", placeholder="e.g., heavy chalk; spread race; vulnerable favoriteâ€¦")

# Step 2 â€” Styles, Bias, Scratches
st.markdown("## Step 2 â€” Confirm scratches & running styles")
df_styles_full = extract_horses_and_styles(pp_text) if pp_text.strip() else pd.DataFrame()
detected_horses = list(df_styles_full["Horse"]) if not df_styles_full.empty else []
if pp_text.strip() and not detected_horses:
    st.warning("We couldnâ€™t find the numbered entry lines (like `1 Horse Name (E 4)`). Itâ€™s still OKâ€”paste the part with the horse list.")
field_size = len(detected_horses)

col1, col2 = st.columns([1.2, 1])
with col1:
    bias_options = [
        "favors speed", "favors stalkers", "favors closers",
        "inside bias (posts 1-3)", "mid bias (posts 4-7)",
        f"outside bias ({'8+' if field_size>=8 else '8+'})",
        "tiring speed", "fair/neutral"
    ]
    biases = st.multiselect("Track bias today:", options=bias_options, default=["fair/neutral"])
with col2:
    st.write("**Post Bias Key**")
    st.info(compute_post_bias_label(field_size or 8))

st.markdown("**Scratches**")
scratched_by_pick = st.multiselect("Detected horses to scratch:", options=detected_horses, default=[])
scratches_manual = st.text_input("Or type numbers/names (comma or new line):", placeholder="e.g., 2, 7, Holiday Fantasy")
scratch_set = set([h.strip().lower() for h in scratched_by_pick])
if scratches_manual.strip():
    for tok in re.split(r"[,\n]+", scratches_manual):
        tok = tok.strip()
        if tok: scratch_set.add(tok.lower())

df_styles = df_styles_full.copy()
if not df_styles.empty and scratch_set:
    mask = ~df_styles["Horse"].str.lower().isin(scratch_set) & ~df_styles["#"].astype(str).str.lower().isin(scratch_set)
    df_styles = df_styles[mask].reset_index(drop=True)

style_options = ["", "E", "E/P", "P", "S"]
strength_options = ["Strong", "Solid", "Slight", "Weak", "Bias"]
edited = st.data_editor(
    df_styles,
    column_config={
        "#": st.column_config.Column(disabled=True, width="small"),
        "Horse": st.column_config.Column(disabled=True),
        "DetectedStyle": st.column_config.Column(disabled=True, help="Parsed from lines like (P 2)"),
        "OverrideStyle": st.column_config.SelectboxColumn("OverrideStyle", options=style_options,
                                                          help="Leave blank to keep detected."),
        "StyleStrength": st.column_config.SelectboxColumn("StyleStrength", options=strength_options,
                                                          help="Run-style conviction."),
    },
    hide_index=True, use_container_width=True, num_rows="fixed",
)
st.caption("E=Early; E/P=Early/Presser; P=Mid-pack; S=Closer. â€˜Style Strengthâ€™ = consistency (Strong/Solid/Slight/Weak/Bias).")

running_styles_text = _format_running_styles(edited) if isinstance(edited, pd.DataFrame) and not edited.empty else "None detected"
scratches_list = sorted(scratch_set)

# Surface condition
if surface_type == "Dirt":
    surface_condition = st.selectbox("Condition:", ["fast","muddy","sloppy","wet-fast","good","off"], index=0)
elif surface_type == "Turf":
    surface_condition = st.selectbox("Condition:", ["firm","good","yielding","soft","off"], index=0)
else:
    surface_condition = st.selectbox("Condition:", ["fast","standard","wet"], index=0)

# Step 3 â€” Optional Angle/Stat rows
st.markdown("## Step 3 â€” (Optional) add angle stats")
st.caption("Paste lines like: `1st time str   146   3%   25%   -1.22` (Category â€¢ Starts â€¢ Win% â€¢ ITM% â€¢ ROI)")
angles_raw = st.text_area("Angle rows:", height=120, placeholder="Category  Starts  Win%  ITM%  ROI")
angles_df = parse_stat_table_lines(angles_raw.split("\n")) if angles_raw.strip() else pd.DataFrame()
if not angles_df.empty: st.dataframe(angles_df, use_container_width=True)

# ===================== Step 4 â€” Live Tote / Board (FIXED) =====================
st.markdown("## Step 4 â€” (Optional) enter current odds (from the tote)")
st.caption("Type odds like 7/2, 5-1, +250, or 4.6; we convert automatically.")

board_mode = st.radio(
    "How do you want to enter odds?",
    ["Quick paste (free text)", "Table editor (per horse)"],
    index=1,
    horizontal=True
)

board_dec: Dict[str, float] = {}

if board_mode == "Quick paste (free text)":
    tote_raw = st.text_area(
        "Board odds (one per line: Horse = odds):",
        height=120,
        placeholder="Ashkenazi = 7/2\nCinnamon Sugar = 9/2\nBlazing Freedom = +300"
    )

    def parse_board(block: str) -> Dict[str, float]:
        out = {}
        for line in (block or "").split("\n"):
            if "=" not in line:
                continue
            name, odd = line.split("=", 1)
            dec = str_to_decimal_odds(odd.strip())
            if dec:
                out[name.strip()] = dec
        return out

    board_dec = parse_board(tote_raw)

else:
   # --- ALWAYS rebuild/clean the board editor dtypes to avoid Text/FLOAT conflicts ---
    horses_for_board = [h for h in detected_horses if h.lower() not in scratch_set]

    # Reset button (appears only when table mode is chosen)
    reset_board = st.button("ðŸ”„ Reset odds editor (clear & rebuild)", use_container_width=False)

    if ("board_df" not in st.session_state) or reset_board:
        st.session_state.board_df = pd.DataFrame(
            {
                "Horse": horses_for_board,
                "Odds (enter any format)": ["" for _ in horses_for_board],  # <-- TEXT ONLY
                "Decimal": [np.nan for _ in horses_for_board],              # floats (computed)
                "Board %": [np.nan for _ in horses_for_board],              # floats (computed)
            }
        )

    # Make a working copy and **force** the correct dtypes every render
    df_board = st.session_state.board_df.copy()

    # Key line: ensure the input column is STRING (no NaN)
    if "Odds (enter any format)" in df_board.columns:
        df_board["Odds (enter any format)"] = (
            df_board["Odds (enter any format)"]
            .astype("string")        # pandas StringDtype
            .fillna("")              # no NaN in a Text column
        )

    # Ensure computed columns are numeric (OK if NaN)
    for col in ["Decimal", "Board %"]:
        if col in df_board.columns:
            df_board[col] = pd.to_numeric(df_board[col], errors="coerce")

    edit_df = st.data_editor(
        df_board,
        column_config={
            "Horse": st.column_config.Column(disabled=True),
            # The input must be TextColumn to allow any format (7/2, +250, 4.3, etc)
            "Odds (enter any format)": st.column_config.TextColumn(
                help="Type odds like 7/2, 5-1, +250, or 4.6"
            ),
            "Decimal": st.column_config.NumberColumn(format="%.3f", disabled=True),
            "Board %": st.column_config.NumberColumn(format="%.2f", disabled=True),
        },
        hide_index=True,
        use_container_width=True,
    )

    # Recompute Decimal/Board% from the typed odds (safe even if empty)
    decs, probs = [], []
    board_dec = {}
    for _, r in edit_df.iterrows():
        raw = (r.get("Odds (enter any format)") or "").strip()
        dec = str_to_decimal_odds(raw) if raw else None
        p = dec_to_prob(dec) if dec else np.nan
        decs.append(dec if dec else np.nan)
        probs.append(p * 100 if dec else np.nan)
        if dec:
            board_dec[r["Horse"]] = dec

    edit_df["Decimal"] = decs
    edit_df["Board %"] = probs

    # Persist back to session
    st.session_state.board_df = edit_df

    st.dataframe(edit_df, use_container_width=True, hide_index=True)
# Step 5 â€” Analyze
st.markdown("## Step 5 â€” Run analysis")
weight_preset = get_weight_preset(surface_type, distance_txt) if iq_mode else DEFAULT_WEIGHTS["global"]
first_time_starter_hint = any(x in (pp_text or "") for x in ["Mdn", "MSW", "Maiden"])

def build_user_prompt(pp_text: str, biases, surface_type: str, surface_condition: str,
                      scratches_list, running_styles_text: str, ml_context: str,
                      profile: str, angles_df: pd.DataFrame, iq_mode: bool,
                      weight_preset: Dict[str, float], first_time_starter_hint: bool):
    style_glossary = (
        "Running Style Glossary:\n"
        "â€¢ E (Early/Front-Runner); â€¢ E/P (Early/Presser); â€¢ P (Stalker mid-pack); â€¢ S (Closer).\n"
        "Use strength tags (Strong/Solid/Slight/Weak/Bias) to calibrate confidence.\n"
    )
    scratches_txt = ", ".join(scratches_list) if scratches_list else "none"
    angles_block = ""
    if angles_df is not None and not angles_df.empty:
        angles_block = "Angle/Stat Table (Category â€¢ Starts â€¢ Win% â€¢ ITM% â€¢ ROI):\n" + \
                       "\n".join([f"â€¢ {r.Category} â€¢ {r.Starts} â€¢ {r['Win%']}% â€¢ {r['ITM%']}% â€¢ {r.ROI:+.2f}"
                                  for _, r in angles_df.iterrows()])
    profile_rules = {
        "Value Hunter": "Prioritize overlays; fade underlays; aggressive spreads in chaos pace or MSW with many FTS.",
        "Balanced": "Blend fair odds with obvious form; moderate spreads; protect vs. pace extremes.",
        "Exotic Builder": "Press verticals (Ex/Tri/Super/SH5) using pace maps and A/B/C tiers; lean into chaos fields.",
        "Steady Chalk": "Shorten tickets; single logical chalk when fair; avoid low-EV spray-and-pray."
    }
    preset_line = "Weight Preset: " + json.dumps(weight_preset)
    fts_line = "Apply FTS/MSW logic for debuters and stakes-eligible firsters (trainer debut %, sire FTS %, works, auction premium/fee ratio, gate works, distance fit)."
    return f"""
You are an elite, value-driven handicapper. Use pace figures, class ratings, bias patterns (post+run style),
form cycles, trainer & jockey intent, pedigree tendencies, workout signals, and first-time starter (FTS) heuristics.

Strategy Profile: {profile} â€” {profile_rules.get(profile,'')}
IQ Mode: {"ON" if iq_mode else "OFF"} | {preset_line}
Special: {fts_line}

Track Bias Today: {', '.join(biases) if biases else 'fair/neutral'}
Surface: {surface_type} ({surface_condition})
Scratches (exclude entirely): {scratches_txt}

{style_glossary}
Horse Running Styles (respect; adjust only if projection is obvious):
{running_styles_text or 'None detected'}

Notes: {ml_context or 'N/A'}

{angles_block or ''}

Past Performances (BRIS â€” single race):
{pp_text}

Return the result in this exact structure (concise bullets):
Race Summary â€“ Track, race #, surface, distance, class, purse.
Pace Shape Analysis â€“ Early/fast/honest/slow? Collapse risk? Who benefits?
Bias Fit â€“ Inside/Mid/Outside posts; speed vs closers; cite strength tags if relevant.
Top Contenders â€“ Rank 1â€“4 with one-line reasons (style â€¢ bias â€¢ form cycle â€¢ trainer/jockey â€¢ pedigree/FTS).
Fair Odds Line â€“ Assign win % (sum â‰¤ 100%), and fair odds (AM).
Overlays / Underlays â€“ Based on fair vs likely tote.
Ticket Builder â€“
â€¢ Win â€“ horses with minimum acceptable odds.
â€¢ Exacta â€“ keys/boxes (A/B structure).
â€¢ Trifecta â€“ efficient structure (A with B/C; saver).
â€¢ Superfecta â€“ A/B/C/D tiers (efficient coverage).
â€¢ Super High Five â€“ compact A/B/C/D/E sketch if field size â‰¥ 7.
Pass/Press Guidance â€“ When to pass; when to press if overlays â‰¥ threshold.
Confidence Rating â€“ 1â€“5 stars.
Rules: No scratched horses; adjust for bias/condition; respect listed Running Styles; apply FTS/MSW logic.
"""

go = st.button("Analyze this race", type="primary", use_container_width=True)

if go:
    if not pp_text.strip():
        st.warning("Please paste BRIS PPs for a single race.")
        st.stop()
    if len(race_headers) > 1:
        st.error("Multiple races detected â€” please paste only one race.")
        st.stop()

    user_prompt = build_user_prompt(
        pp_text=pp_text.strip(),
        biases=biases,
        surface_type=surface_type,
        surface_condition=surface_condition,
        scratches_list=scratches_list,
        running_styles_text=running_styles_text,
        ml_context=ml_context.strip(),
        profile=profile,
        angles_df=angles_df,
        iq_mode=iq_mode,
        weight_preset=weight_preset,
        first_time_starter_hint=first_time_starter_hint
    )

    with st.spinner("Handicappingâ€¦"):
        try:
            messages = [
                {"role": "system",
                 "content": "You are a professional value-based handicapper. Focus on value, pace, bias, class, form cycles, trainer/jockey intent, pedigree tendencies, first-time starter logic, and efficient exotic structures."},
                {"role": "user", "content": user_prompt},
            ]
            analysis_text = call_openai_messages(messages)
        except Exception as e:
            st.error(f"OpenAI error: {e}")
            st.stop()

    st.success("Analysis complete.")
    st.markdown(analysis_text)
    st.download_button("Download analysis (.txt)", data=analysis_text,
                       file_name="horse_racing_analysis.txt",
                       mime="text/plain", use_container_width=True)

    # Parse a simple fair line (Horse â€” %)
    fair_probs = {}
    try:
        for line in analysis_text.splitlines():
            m = re.match(r'^\s*([A-Za-z0-9\'\.\-\s&]+?)\s+[â€“-]\s+(\d+(?:\.\d+)?)\s*%', line)
            if m:
                name = m.group(1).strip()
                p = float(m.group(2))/100.0
                fair_probs[name] = p
    except Exception:
        pass

    # Confidence bands
    if fair_probs:
        band = conf_band/100.0
        band_rows=[]
        for h,p in fair_probs.items():
            lo=max(0,p-band); hi=min(1,p+band)
            band_rows.append({"Horse":h,"Fair%":round(p*100,2),"Low%":round(lo*100,2),"High%":round(hi*100,2),
                              "Fair AM": fair_to_american(p)})
        st.markdown("#### Confidence bands (Â±)")
        st.dataframe(pd.DataFrame(band_rows), use_container_width=True)

    # Overlays based on live board
    st.markdown("#### Live overlay/underlay scan")
    st.caption("**Overlays = value.** If our fair win% > boardâ€™s implied %, itâ€™s an overlay (positive EV). Underlays are the opposite.")
    if fair_probs and board_dec:
        df_overlay = overlay_table(fair_probs, board_dec)
        st.dataframe(df_overlay, use_container_width=True)
        st.caption(f"Press guidance: consider pressing when overlay â‰¥ {press_threshold:.1f} percentage points and EV per $1 is positive.")
    elif fair_probs and not board_dec:
        st.caption("Enter any live odds above to see overlays and EV per $1.")

    # ===================== Build tickets (optional) =====================
    st.markdown("## Build tickets (optional)")
    # Advanced controls grouping
    if beginner_mode:
        with st.expander("Advanced controls (optional)", expanded=False):
            colW, colE = st.columns(2)
            with colW:
                base_win = st.number_input("Base Win stake ($):", min_value=0.5, value=2.0, step=0.5)
                base_ex  = st.number_input("Exacta base ($):",   min_value=0.1, value=1.0, step=0.1)
                base_tri = st.number_input("Trifecta base ($):", min_value=0.1, value=0.5, step=0.1)
            with colE:
                base_super = st.number_input("Superfecta base ($):", min_value=0.1, value=0.1, step=0.1)
                base_sh5   = st.number_input("Super High Five base ($):", min_value=0.1, value=0.1, step=0.1)

            contenders = [h for h in detected_horses if h.lower() not in scratch_set]
            A = st.multiselect("Tier A â€” Top win candidates", contenders, default=contenders[:1] if contenders else [])
            B = st.multiselect("Tier B â€” Win threats / strong underneath", [h for h in contenders if h not in A], default=[])
            C = st.multiselect("Tier C â€” Underneath value (price)", [h for h in contenders if h not in A and h not in B], default=[])
            D = st.multiselect("Tier D â€” Deep bombs (bottom slots)", [h for h in contenders if h not in A and h not in B and h not in C], default=[])
    else:
        colW, colE = st.columns(2)
        with colW:
            base_win = st.number_input("Base Win stake ($):", min_value=0.5, value=2.0, step=0.5)
            base_ex  = st.number_input("Exacta base ($):",   min_value=0.1, value=1.0, step=0.1)
            base_tri = st.number_input("Trifecta base ($):", min_value=0.1, value=0.5, step=0.1)
        with colE:
            base_super = st.number_input("Superfecta base ($):", min_value=0.1, value=0.1, step=0.1)
            base_sh5   = st.number_input("Super High Five base ($):", min_value=0.1, value=0.1, step=0.1)
        contenders = [h for h in detected_horses if h.lower() not in scratch_set]
        A = st.multiselect("Tier A â€” Top win candidates", contenders, default=contenders[:1] if contenders else [])
        B = st.multiselect("Tier B â€” Win threats / strong underneath", [h for h in contenders if h not in A], default=[])
        C = st.multiselect("Tier C â€” Underneath value (price)", [h for h in contenders if h not in A and h not in B], default=[])
        D = st.multiselect("Tier D â€” Deep bombs (bottom slots)", [h for h in contenders if h not in A and h not in B and h not in C], default=[])

    # Cost Estimates (simple approximations)
    ex_cost  = base_ex  * (len(A)*len(B) + len(B)*len(A) + len(A)*max(len(A)-1,0)) if A and (B or len(A)>=2) else 0.0
    tri_cost = base_tri * (len(A) * max(len(B),1) * max(len(C)+len(B),1)) if A else 0.0
    sup_cost = superfecta_cost(len(A) or 0, max(len(B),1) if A else 0, max(len(C),1) if A else 0, max(len(D),1) if A else 0, base_super)
    sh5_cost = super_high5_cost(len(A) or 0, max(len(B),1) if A else 0, max(len(C),1) if A else 0, max(len(D),1) if A else 0, base_sh5)

    cost_df = pd.DataFrame([
        ["Win (per horse)", base_win],
        ["Exacta (est.)", round(ex_cost,2)],
        ["Trifecta (est.)", round(tri_cost,2)],
        ["Superfecta (est.)", round(sup_cost,2)],
        ["Super High Five (est.)", round(sh5_cost,2)],
    ], columns=["Bet", "Cost ($)"])
    st.dataframe(cost_df, use_container_width=True, hide_index=True)

    # What-If EV for Win bets
    if fair_probs and board_dec and (A or B):
        st.markdown("#### What-If EV (Win)")
        rows=[]
        picks = A + B
        for h in picks:
            p = fair_probs.get(h)
            o = board_dec.get(h)
            if p and o:
                ev = (o-1)*p - (1-p)
                action = "Press" if ((1/o - p) <= -press_threshold/100.0 and ev>0) else "Pass/Small"
                rows.append([h, round(p*100,2), round(o,2), round(ev,3), action])
        if rows:
            st.dataframe(pd.DataFrame(rows, columns=["Horse","Fair%","Board (dec)","EV per $1","Action"]),
                         use_container_width=True, hide_index=True)

# Track your bets (optional)
st.markdown("## Track your bets (optional)")
if "ledger" not in st.session_state:
    st.session_state.ledger = []

with st.form("ledger_form"):
    lcol1, lcol2, lcol3 = st.columns([2,1,1])
    with lcol1: desc = st.text_input("Bet description", placeholder="Win: Ashkenazi @ 7/2")
    with lcol2: stake = st.number_input("Stake ($)", min_value=0.1, value=2.0, step=0.1)
    with lcol3: ret = st.number_input("Return ($)", min_value=0.0, value=0.0, step=0.1, help="Leave 0 if unsettled; update later.")
    add = st.form_submit_button("Add/Update")
    if add and desc:
        st.session_state.ledger.append({"desc": desc, "stake": float(stake), "return": float(ret)})

if st.session_state.ledger:
    led_df = pd.DataFrame(st.session_state.ledger)
    led_df["P/L"] = led_df["return"] - led_df["stake"]
    total_stake = led_df["stake"].sum()
    total_return = led_df["return"].sum()
    pl = total_return - total_stake
    roi = (total_return/total_stake - 1.0)*100 if total_stake>0 else 0.0
    st.dataframe(led_df, use_container_width=True, hide_index=True)
    c1,c2,c3,c4 = st.columns(4)
    c1.metric("Session Stake ($)", f"{total_stake:.2f}")
    c2.metric("Session Return ($)", f"{total_return:.2f}")
    c3.metric("Session P/L ($)", f"{pl:.2f}")
    c4.metric("Session ROI (%)", f"{roi:.2f}")

st.caption("Tip: Enter live odds to see overlays & EV. Beginner Mode keeps things simple; expand Advanced controls anytime.")
