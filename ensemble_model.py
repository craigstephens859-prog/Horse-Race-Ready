"""
Production Torch Ensemble Model
Generated by ML Quant Optimization Pipeline
"""

import torch
import torch.nn as nn
import numpy as np

class ProductionEnsemble(nn.Module):
    """
    Production-ready ensemble model for horse racing predictions.
    
    Optimized weights:
        class          : 1.464
        form           : 1.378
        speed          : 1.302
        pace           : 1.200
        style          : 1.622
        post           : 1.836
        angles         : 0.100
        track_bias     : 1.536
        odds_drift     : 1.339
    """
    
    def __init__(self):
        super().__init__()
        
        # Optimized component weights
        self.weights = {
            'class': 1.464,
            'form': 1.378,
            'speed': 1.302,
            'pace': 1.200,
            'style': 1.622,
            'post': 1.836,
            'angles': 0.100,
            'track_bias': 1.536,
            'odds_drift': 1.339,
        }
        
        # Neural network for non-linear refinement
        self.refiner = nn.Sequential(
            nn.Linear(15, 64),
            nn.BatchNorm1d(64),
            nn.ReLU(),
            nn.Dropout(0.2),
            nn.Linear(64, 32),
            nn.ReLU(),
            nn.Linear(32, 4)  # Win, Place, Show, Fourth
        )
    
    def calculate_base_rating(self, features: torch.Tensor) -> torch.Tensor:
        """
        Calculate base rating using optimized linear weights.
        
        Args:
            features: Tensor of shape (batch_size, 15) with:
                [class, form, speed, pace, style, post, angles,
                 quirin, jockey_win, trainer_win, last_beyer,
                 avg_beyer, track_bias, odds_drift, layoff]
        
        Returns:
            Base ratings (batch_size,)
        """
        
        rating = (
            features[:, 0] * self.weights['class'] +
            features[:, 1] * self.weights['form'] +
            features[:, 2] * self.weights['speed'] +
            features[:, 3] * self.weights['pace'] +
            features[:, 4] * self.weights['style'] +
            features[:, 5] * self.weights['post'] +
            features[:, 6] * self.weights['angles'] +
            features[:, 12] * self.weights['track_bias'] +
            features[:, 13] * self.weights['odds_drift']
        )
        
        return rating
    
    def forward(self, features: torch.Tensor) -> torch.Tensor:
        """
        Full ensemble prediction.
        
        Returns:
            Probabilities (batch_size, 4) for [Win, Place, Show, Fourth]
        """
        
        # Calculate base rating
        base_rating = self.calculate_base_rating(features)
        
        # Refine with neural network
        refined = self.refiner(features)
        
        # Combine: 70% base, 30% neural refinement
        combined = 0.7 * base_rating.unsqueeze(1) + 0.3 * refined[:, 0].unsqueeze(1)
        
        # Convert to probabilities via softmax
        probs = torch.nn.functional.softmax(combined / 3.0, dim=1)
        
        return probs
    
    def predict_race(self, horses: list) -> list:
        """
        Predict finish order for a race.
        
        Args:
            horses: List of dicts with horse features
        
        Returns:
            List of (horse_name, win_prob, place_prob, show_prob, fourth_prob)
        """
        
        # Extract features
        features = []
        names = []
        
        for horse in horses:
            feature_vec = [
                horse.get('class', 0),
                horse.get('form', 0),
                horse.get('speed', 0),
                horse.get('pace', 0),
                horse.get('style_numeric', 0),
                horse.get('post', 0),
                horse.get('angles', 0),
                horse.get('quirin', 0),
                horse.get('jockey_win_pct', 0),
                horse.get('trainer_win_pct', 0),
                horse.get('last_beyer', 0),
                horse.get('avg_beyer', 0),
                horse.get('track_bias', 0),
                horse.get('odds_drift', 0),
                horse.get('days_since_last', 30) / 100.0
            ]
            features.append(feature_vec)
            names.append(horse.get('name', f"Horse_{len(names)+1}"))
        
        # Convert to tensor
        X = torch.tensor(features, dtype=torch.float32)
        
        # Predict
        with torch.no_grad():
            probs = self.forward(X)
        
        # Build results
        results = []
        for i, name in enumerate(names):
            results.append({
                'name': name,
                'win_prob': float(probs[i, 0]),
                'place_prob': float(probs[i, 1]) if probs.shape[1] > 1 else 0.0,
                'show_prob': float(probs[i, 2]) if probs.shape[1] > 2 else 0.0,
                'fourth_prob': float(probs[i, 3]) if probs.shape[1] > 3 else 0.0
            })
        
        # Sort by win probability
        results.sort(key=lambda x: x['win_prob'], reverse=True)
        
        return results


# Usage Example
if __name__ == "__main__":
    model = ProductionEnsemble()
    
    # Sample race
    horses = [
        {'name': 'Fast Runner', 'class': 2.0, 'form': 1.5, 'speed': 1.8,
          'pace': 1.2, 'style_numeric': 2, 'post': 3, 'angles': 0.3},
        {'name': 'Speed Demon', 'class': 1.5, 'form': 2.0, 'speed': 2.2,
          'pace': 0.8, 'style_numeric': 3, 'post': 1, 'angles': 0.2},
        # ... more horses
    ]
    
    predictions = model.predict_race(horses)
    
    print("Predicted Finish Order:")
    for i, pred in enumerate(predictions, 1):
        print(f"{i}. {pred['name']:20} Win: {pred['win_prob']:.1%}")
